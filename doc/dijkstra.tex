\documentclass[12pt]{article}
\usepackage[]{algorithm2e}
\usepackage{ amssymb }
\usepackage{amsmath}
\usepackage[hyphens]{url}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	backgroundcolor=\color{lbcolor},
	tabsize=4,
	language=C++,
	captionpos=b,
	tabsize=3,
	frame=lines,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
	showstringspaces=false,
	basicstyle=\footnotesize,
	%  identifierstyle=\color{magenta},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color{Darkgreen},
	stringstyle=\color{red}
}

\begin{document}

\title{Project 01 CS-790}
\author{Brandon Bluemner}
\date{2017}
\maketitle
% //Start
\begin{abstract}
Analysis and of c++11 implementation of Dijkstra's algorithm. 

\end{abstract}
% ==========================================================================================================================
%  Algorithm Section 1
% ==========================================================================================================================
\section[Algorithm]{Algorithm}
\begin{algorithm}

\KwData{  \textit{source:} source node, \textit{$goal_v$:} collection or goals,\\ \textit{cost:} function that returns cost between edge $u \to u_i$, \\ \textit{succ:} function that returns the neighbors of node u   }
\KwResult{ \textit{path:} collection to store path in}
\SetKwProg{Fn}{Function}{}{}
\Fn{run(source, $goal_v$, path, cost, succ)}{
	$I$ u;
	$T$ \_cost $\leftarrow \infty$;
	$frontier.push( {0,source})$ // priority que \\
	$current.insert(source)$ //keep track of current node in frontier \\
	$map<I,T> g $ // This will keep track of cost for node I cost T\\
	$g[source]$  $\leftarrow$  0;
	$I _goal$ $\leftarrow goal_v.at(0)$\\
	\While{ $frontier.empty() = false$}{
		$u$ $\leftarrow$ frontier.top() // get next node \\
		$frontier.pop()$  // move remove the next from the que \\
		$current.erase(current.find(u))$ // remove u from current \\		
		\For{$auto goal$ $\in$ $goal_v$}{ 
			\If{$ u = goal$ and $g[goal]<$\_cost}{
				\_cost  $\leftarrow g[goal]$;
				\_goal  $\leftarrow goal$ \\
			}
		}
		$explored.insert(u)$;
		$vector<Edge> successor$; $ succ(u,successor)$;
		\\
			\For{$ auto$ $s : successor $} {
				$I ui \leftarrow s.get_target()$\\
				// ui not in E and ui not in f\\
				\If{$explored.find(ui) = explored.end() and current.find(ui) = current.end()$}{
						$g[ui] \leftarrow g[u] + cost(u,ui) frontier.push({g[ui],ui})$\\
						$current.insert(ui)$;
						$path[ui] \leftarrow u$
				}					
				\ElseIf{$current.find(ui) \neq current.end()$}{
					\If{ $g[u] + cost(u,ui) < g[ui]$ }{
						$g[ui] \leftarrow g[u] + cost(u,ui)$;
						$path[ui] \leftarrow u$
					}
				}				
				\ElseIf{$explored.find(ui) \neq explored.end()$}
				{
					\If{ $g[u] + cost(u,ui) < g[ui] $}{
						$explored.erase(explored.find(ui))$;
						$frontier.push({g[ui],ui})$;
						$current.insert(source)$;
					}
				}
		}
	}
}
\end{algorithm}
\clearpage
% ==========================================================================================================================
%  Implementation Section 2
% ==========================================================================================================================
\section[Implementation]{Implementation}
The implementation of Dijkstra utilizes several of the c++11 standard library. c++11
included several enhancements to the predefined data structures since the last revision. Below is how the
 data structures are defined and the running time of their 
%----------------------------------------
%	Std::Vector
% ---------------------------------------
\subsection{std::vector}
\begin{lstlisting}
	template<
    class T,
    class Allocator = std::allocator<T>
> class vector;
\end{lstlisting}
\begin{tabular}{ l l l }
\textbf{Constructors} & \textbf{Description} & \textbf{Big - OH}\\
vector$<$T$>$ v; & Make an empty vector. & O(1)\\
vector$<$T$>$ v(n); & Make a vector with N elements. & O(n)\\
vector$<$T$>$ v(n, value); & Make a vector with N elements, initialized to value. & O(n)\\
vector$<$T$>$ v(begin, end); & Make a vector and copy the elements from begin to end & O(n)\\
\end{tabular}
\\
\\
\\
\begin{tabular}{ l l l }
\textbf{Accessors} & \textbf{Description} & \textbf{Big - OH}\\
v[i]; & Return (or set) the I'th element. & O(1)\\
v.at(i); & Return (or set) the I'th element, with bounds checking. & O(1)\\
v.size(); & Return current number of elements. & O(1)\\
v.empty(); & Return true if vector is empty. & O(1)\\
v.begin(); & Return random access iterator to start. & O(1)\\
v.end(); & Return random access iterator to end. & O(1)\\
v.front(); & Return the first element. & O(1)\\
v.back(); & Return the last element. & O(1)\\
v.capacity(); & Return maximum number of elements. & O(1)\\
\end{tabular}
\\
\\
\\
\begin{tabular}{ l l l }
\textbf{Modifiers} & \textbf{Description} & \textbf{Big - OH}\\
v.push\_back(value); & Add value to end. & O(1) (amortized)\\
v.insert(iterator, value); & Insert value at the position indexed by iterator. & O(n)\\
v.pop\_back(); & Remove value from end. & O(1)\\
v.erase(iterator); & Erase value indexed by iterator. & O(n)\\
v.erase(begin, end); & Erase the elements from begin to end & O(n)\\
\end{tabular}
\clearpage
%----------------------------------------
%	Std::priority queue
% ---------------------------------------
\subsection{std::priority\_queue}\label{pq}
\begin{tabular}{ p{5cm} p{7cm} p{5cm}}
\textbf{Constructors} & \textbf{Description} & \textbf{Big - OH}\\
priority\_queue$<$T,  container$<$T$>$,  comparison$<$T$>$ $>$ q & Make an empty priority queue using the given container to hold values, and comparison to compare values. container defaults to vector$<$T$>$ and comparison defaults to less$<$T$>$. & O(1)\end{tabular}
\\
\\
\\
\begin{tabular}{ l l l }
\textbf{Accessors} & \textbf{Description} & \textbf{Big - OH}\\
q.top(); & Return the ``biggest'' element. & O(1)\\
q.size(); & Return current number of elements. & O(1)\\
q.empty(); & Return true if priority queue is empty. & O(1)
\end{tabular}
\\
\\
\\
\begin{tabular}{ l l l }
\textbf{Modifiers} & \textbf{Description} & \textbf{Big - OH}\\
q.push(value); & Add value to priority queue. & O(log n)\\
q.pop(); & Remove biggest value. & O(log n)\\
\end{tabular}
\clearpage
%----------------------------------------
%	Std::Set
% ---------------------------------------
\subsection{std::set} \label{stdset}
\begin{tabular}{ p{5cm} p{7cm} p{5cm}}
\textbf{Constructors} & \textbf{Description} & \textbf{Big - OH}\\
set $<$type, compare$>$ s; & Make an empty set. compare should be a binary predicate for ordering the set. It's optional and will default to a function that uses operator$<$. & O(1)\\
set $<$type, compare$>$ s(begin, end); & Make a set and copy the values from begin to end. & O(n log n)
\end{tabular}
\\
\\
\\
\begin{tabular}{ p{5cm} p{7cm}  p{5cm}}
\textbf{Modifiers} & \textbf{Description} & \textbf{Big - OH}\\
s.find(key) & Return an iterator pointing to an occurrence of key in s, or s.end() if key is not in s. & O(log n)\\
s.lower\_bound(key) & Return an iterator pointing to the first occurrence of  an item in s not less than key, or s.end() if no such item is found. & O(log n)\\
s.upper\_bound(key) & Return an iterator pointing to the first occurrence of  an item greater than key in s, or s.end() if no such item is found. & O(log n)\\
s.equal\_range(key) & Returns pair$<$lower\_bound(key), upper\_bound(key)$>$. & O(log n)\\
s.count(key) & Returns the number of items equal to key in s. & O(log n)\\
s.size() & Return current number of elements. & O(1)\\
s.empty() & Return true if set is empty. & O(1)\\
s.begin() & Return an iterator pointing to the first element. & O(1)\\
s.end() & Return an iterator pointing one past the last element. & O(1)
\end{tabular}
\clearpage
%----------------------------------------
%	Std::Map
% ---------------------------------------
\subsection{std::Map}
\begin{tabular}{ p{5cm} p{7cm}  p{5cm} }
\textbf{Constructors} & \textbf{Description} & \textbf{Big - OH}\\
map$<$ key\_type, value\_type, key\_compare $>$ m; & Make an empty map. key\_compare should be a binary predicate for ordering the keys. It's optional and will default to a function that uses operator$<$. & O(1)\\
map$<$ key\_type, value\_type, key\_compare $>$ m(begin, end); & Make a map and copy the values from begin to end. & O(n log n)
\end{tabular}
\\
\\
\\
\begin{tabular}{ p{5cm} p{7cm}  p{5cm} }
\textbf{Accessors} & \textbf{Description} & \textbf{Big - OH}\\
m[key] & Return the value stored for key. This adds a default value if key not in map. & O(log n)\\
m.find(key) & Return an iterator pointing to a key-value pair, or m.end() if key is not in map. & O(log n)\\
m.lower\_bound(key) & Return an iterator pointing to the first pair containing key, or m.end() if key is not in map. & O(log n)\\
m.upper\_bound(key) & Return an iterator pointing one past the last pair containing key, or m.end() if key is not in map. & O(log n)\\
m.equal\_range(key) & Return a pair containing the lower and upper bounds for key. This may be more efficient than calling those functions separately. & O(log n)\\
m.size(); & Return current number of elements. & O(1)\\
m.empty(); & Return true if map is empty. & O(1)\\
m.begin() & Return an iterator pointing to the first pair. & O(1)\\
m.end() & Return an iterator pointing one past the last pair. & O(1) n)
\end{tabular}
\\
\\
\\
\begin{tabular}{ p{5cm} p{7cm}  p{5cm} }
\textbf{Modifiers} & \textbf{Description} & \textbf{Big - OH}\\
m[key] = value; & Store value under key in map. & O(log n)\\
m.insert(pair) & Inserts the <key, value> pair into the map. Equivalent to the above operation. & O(log n)
\end{tabular}
\subsection{std::pair}
\begin{tabular}{ p{5cm} p{10cm} }
default (1) & constexpr pair\\
copy / move (2) & template$<$class U, class V$>$ pair (const pair$<$U,V$>$\& pr);
					template$<$class U, class V$>$ pair (pair$<$U,V$>$\&\& pr);
					pair (const pair\& pr) = default;
					pair (pair\&\& pr) = default;\\
initialization (3) & pair (const first\_type\& a, const second\_type\& b);
					template$<$class U, class V$>$ pair (U\&\& a, V\&\& b);\\
piecewise (4) &		
					template $<$class... Args1, class... Args2$>$
  					pair (piecewise\_construct\_t pwc, tuple$<$Args1...$>$ first\_args,
                                   tuple$<$Args2...$>$ second\_args);
					
					
\end{tabular}
\begin{lstlisting}

template <class T1,class T2>
  pair<T1,T2> make_pair (T1 x, T2 y)
  {
    return ( pair<T1,T2>(x,y) );
  }
\end{lstlisting}
%----------------------------------------
%	Betacore::Graph
% ---------------------------------------
\subsection{Betacore::Graph}
\begin{lstlisting}
	template<typename T, typename I>
	class Graph{
		private:
			std::vector<betacore::Node<I>> nodes
			std::vector<betacore::Edge<T,I>> edges
			betacore::Node<I> * source
			std::vector<betacore::Node<I>> targets
			void parse_line(std::string &line)
		public:
			Graph()
			void successor(I &node, std::vector<Edge<T,I>> &result)
			void get_edges(std::vector<betacore::Edge<T,I>> &edges)
			Node<I> get_node(I id)
			void add_node(Node<I> &node)
			void remove_node(I id)
			load_from_file(std::string file_path)
			T cost(I u, I ui)
			void print()
	};
\end{lstlisting}

Betacore::graph is an implementation of a directed graph that reads from a
modified comma delimited file. This allows for the graph state to change
without recompiling the code, however this is a potential bottleneck due to
the read speed of a hard disk. (for larger gig size files this should be
be modified to a stream and the graph split up into regions.then each region
only when need thus saving memory ). 

Template$<$typename T, typename I$>$ allows the precision of the graph type to 
be determined by the implementation. T being a float, double, or long double
used for floating point arithmetic. I being a char, int, long, long long int is
used for indexing the nodes. Depending on the size of the graph changing the 
data types for T and I can have a performance and precision impact on the graph.

%----------------------------------------
%	Betacore::Dijkstra
% ---------------------------------------
\subsection{Betacore::Dijkstra}
\begin{lstlisting}
	struct Dijkstra_Exception : public std::exception {
		const char * what () const throw () {
			return "Dijkstra Exception";
		}
	};

	template<typename T, typename I>
	class Dijkstra{
		private:
			std::priority_queue<std::pair<T,I>,std::vector<std::pair<T,I>>, std::greater<std::pair<T,I>> > frontier;
			std::set<I> current; 
			std::set<I> explored;
			T cost();
		public:
			Dijkstra(){
			}
			~Dijkstra(){
			}
		
			void run (
				I source,
				I goal,
				std::map<I,I> &path,
				std::function<T( I u, I ui)> &cost,
				std::function<void(I &node, std::vector<Edge<T,I>> &result)> &Succ
			 );
		
			void run (
				I source,
				std::vector<I> &goal_v,
				std::map<I,I> &path,
				std::function<T( I u, I ui)> &cost,
				std::function<void(I &node, std::vector<Edge<T,I>> &result)> &Succ
			 );
	
	};
\end{lstlisting}

Betacore::Dijkstra implementation has utilizes the std::priority\_queue (see section \ref{pq}).
The priority\_queue uses the std::greater function which set the que by the value in edge cost$<$T$>$. We want grater
so the value in first position will be the smallest, thus the shortest edge$<$T$>$. 
Limitation of using std::priority\_queue is that their is no contains method. That 
problem is overcome by keeping a std::set (see section \ref{stdset}) to keep track of nodes in the frontier.
So the std::priority\_queue frontier keeps the order of the edges and std::set current keeps track of the contains.
This adds double space complexity but saves from have to implement a new child class of std::priority\_queue. Nodes 
are know by their index type I and the edges edges by the edge class.
\\
\\
\begin{lstlisting}
	std::function<T( I u, I ui)> &cost
\end{lstlisting}
This function passed into the algorithm determines the cost from node $u \to u_i$ and 
must be provided by the user and allows for the most flexibility.
\\
\begin{lstlisting}
	std::function<void(I &node, std::vector<Edge<T,I>> &result)> &Succ
\end{lstlisting}
This function passed into the algorithm determines then neighbors nodes of $u$ and
stores the result into a std::vector \&result. To change the implement just make sure
that you add the Edge$<$T,I$>$ index I do the vector list.
% ==========================================================================================================================
%  Proof of correctness Section 3
% ==========================================================================================================================

% \section[Proof of correctness]{Proof of correctness}
\section{Proof of correctness}

\subsection{Flight Plans}

\subsection{Missionaries and Cannibals}
With run of $n=3$ and $m=2$ \\
The graph in the format:\\
Each node represents the following\\

N: Type of node\\

\#: id of the node\\

Name: LHS(Missionaries\_Cannibals)::Boat(Missionaries\_Cannibals)::RHS(Missionaries\_Cannibals)\\
\\
Each Edge is source, target, cost\\
Boat move from LHS $\to$ RHS
\begin{lstlisting}
	File grap_can_n_3_m_2.csv:
	N,0,N::3_2::0_0::0_0
	N,1,N::2_1::1_1::0_0
	N,2,N::3_0::0_2::0_0
	N,3,N::1_2::2_0::0_0
	N,4,N::2_1::0_1::1_0
	N,5,N::2_1::1_0::0_1
	N,6,N::2_0::0_1::0_1
	N,7,N::3_0::0_1::0_1
	N,8,N::1_1::1_1::1_0
	N,9,N::2_0::0_2::1_0
	N,10,N::2_0::1_1::0_1
	N,11,N::1_1::2_0::0_1
	N,12,N::1_1::0_1::2_0
	N,13,N::1_1::1_0::1_1
	N,14,N::2_0::0_1::1_1
	N,15,N::2_0::1_0::0_2
	N,16,N::1_0::2_0::0_1
	N,17,N::1_0::1_1::2_0
	N,18,N::1_0::0_2::2_0
	N,19,N::1_0::0_1::2_1
	N,20,N::0_1::0_1::3_0
	N,21,N::1_0::1_0::1_2
	N,22,N::0_0::1_1::2_1
	N,23,N::0_0_::0_2::3_0
	N,24,N::0_0::0_0::3_2
	E,0,1,1
	E,0,2,1
	E,0,3,1
	E,1,4,1
	E,1,5,1
	E,2,6,1
	E,4,7,1
	E,4,8,1
	E,5,9,1
	E,5,10,1
	E,6,9,1
	E,7,11,1
	E,7,12,1
	E,8,13,1
	E,9,13,1
	E,11,15,1
	E,11,16,1
	E,12,16,1
	E,13,17,1
	E,14,18,1
	E,15,19,1
	E,16,20,1
	E,17,19,1
	E,17,21,1
	E,18,21,1
	E,19,22,1
	E,20,23,1
	E,22,24,1
	E,23,24,1
	S,0,N::3_2::0_0::0_0
	T,24,N::0_0::0_0::3_2
\end{lstlisting}

With run of $n=4$ and $m=3$ 
The graph in the format:\\
Each node represents the following\\

N: Type of node\\

\#: id of the node\\

Name: LHS(Missionaries\_Cannibals)::Boat(Missionaries\_Cannibals)::RHS(Missionaries\_Cannibals)\\
\\
Each Edge is source, target, cost\\
Boat move from LHS $\to$ RHS
\begin{lstlisting}
File grap_can_n_4_m_3.csv:
N,0,4_3::0_0::0_0
N,1,3_2::1_1::0_0
N,2,4_1::0_2::0_0
N,3,2_3::2_0::0_0
N,4,3_2::1_0::0_1
N,5,3_2::0_1::1_0
N,6,4_1::0_1::0_1
N,7,3_1::1_1::0_1
N,8,2_2::2_0::0_1
N,9,2_2::1_1::1_0
N,10,3_1::0_2::1_0
N,11,4_0::0_2::0_1
N,12,3_1::1_0::0_2
N,13,3_1::0_1::1_1
N,14,2_2::1_0::1_1
N,15,2_2::0_1::2_0
N,16,4_0::0_1::0_2
N,17,2_1::2_0::0_2
N,18,3_0::1_1::0_2
N,19,3_0::0_2::1_1
N,20,2_1::1_1::1_1
N,21,1_2::2_0::1_1
N,22,2_1::0_2::2_0
N,23,2_1::1_0::1_2
N,24,3_0::1_0::0_3
N,25,3_0::0_1::1_2
N,26,2_1::0_1::2_1
N,27,2_1::1_0::1_2
N,28,2_0::2_0::0_3
N,29,2_0::0_2::2_1
N,30,1_1::1_1::2_1
N,31,2_0::1_0::1_3
N,32,2_0::0_1::2_2
N,33,1_1::0_1::3_1
N,34,1_1::1_0::2_2
N,35,1_0::1_1::2_2
N,36,1_0::0_2::3_1
N,37,0_1::1_1::3_1
N,38,0_1::2_0::2_2
N,39,1_0::1_0::2_3
N,40,1_0::0_1::3_2
N,41,0_1::1_0::3_2
N,42,0_1::0_1::4_1
N,43,0_0::1_1::3_2
N,44,0_0::0_2::4_1
N,45,0_0::0_0::4_3
E,0,1,1
E,0,2,1
E,0,3,1
E,1,4,1
E,1,5,1
E,2,6,1
E,4,7,1
E,4,8,1
E,5,9,1
E,5,10,1
E,6,11,1
E,7,12,1
E,7,13,1
E,8,14,1
E,9,14,1
E,9,15,1
E,10,13,1
E,11,16,1
E,12,17,1
E,12,18,1
E,13,19,1
E,13,20,1
E,14,20,1
E,14,21,1
E,15,22,1
E,15,23,1
E,16,18,1
E,17,23,1
E,18,24,1
E,18,25,1
E,19,25,1
E,20,26,1
E,20,23,1
E,22,26,1
E,24,28,1
E,26,29,1
E,26,30,1
E,28,31,1
E,29,32,1
E,30,33,1
E,30,34,1
E,32,35,1
E,33,36,1
E,33,37,1
E,34,38,1
E,35,39,1
E,35,40,1
E,36,40,1
E,37,41,1
E,37,42,1
E,38,41,1
E,40,43,1
E,41,43,1
E,42,44,1
E,43,45,1
E,44,45,1
S,0,4_3::0_0::0_0
T,45,0_0::0_0::4_3
\end{lstlisting}

45$\leftarrow$43$\leftarrow$40$\leftarrow$35$\leftarrow$32$\leftarrow$29$\leftarrow$26$\leftarrow$20$\leftarrow$13$\leftarrow$7$\leftarrow$4$\leftarrow$1$\leftarrow$0
the path can be trace from the source to the sink with the sink\\target state matching the gaol state
\\
The output cost 12 is correct because the depth of the tree which represents
this problem is 12 and because each edge has a weight of 1 the cost should equal the depth of the tree.


% //END

\bibliographystyle{unsrt}
\bibliography{bib}


\end{document}
