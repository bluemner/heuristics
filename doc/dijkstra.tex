\documentclass[12pt]{article}
\usepackage[]{algorithm2e}
\usepackage{ amssymb }
\usepackage{amsmath}
\usepackage[hyphens]{url}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	backgroundcolor=\color{lbcolor},
	tabsize=4,
	language=C++,
	captionpos=b,
	tabsize=3,
	frame=lines,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
	showstringspaces=false,
	basicstyle=\footnotesize,
	%  identifierstyle=\color{magenta},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color{Darkgreen},
	stringstyle=\color{red}
}

\begin{document}

\title{Project 01 CS-790}
\author{Brandon Bluemner}
\date{2017}
\maketitle
% //Start
\begin{abstract}
Analysis of c++11 implementation of Dijkstra's algorithm. 

\end{abstract}

% ==========================================================================================================================
%  Algorithm Section 1
% ==========================================================================================================================
\section[Algorithm]{Algorithm}

Algorithm taken from class with some additional information for wiki \cite{ Wikipedia}.
\begin{algorithm}

\KwData{  \textit{source:} source node, \textit{$goal_v$:} collection or goals,\\ \textit{cost:} function that returns cost between edge $u \to u_i$, \\ \textit{succ:} function that returns the neighbors of node u   }
\KwResult{ \textit{path:} collection to store path in}
\SetKwProg{Fn}{Function}{}{}
\Fn{run(source, $goal_v$, path, cost, succ)}{
	$I$ u;
	$T$ \_cost $\leftarrow \infty$;
	$frontier.push( {0,source})$ // priority que \\
	$current.insert(source)$ //keep track of current node in frontier \\
	$map<I,T> g $ // This will keep track of cost for node I cost T\\
	$g[source]$  $\leftarrow$  0;
	$I _goal$ $\leftarrow goal_v.at(0)$\\
	\While{ $frontier.empty() = false$}{
		$u$ $\leftarrow$ frontier.top() // get next node \\
		$frontier.pop()$  // move remove the next from the que \\
		$current.erase(current.find(u))$ // remove u from current \\		
		\For{$auto goal$ $\in$ $goal_v$}{ 
			\If{$ u = goal$ and $g[goal]<$\_cost}{
				\_cost  $\leftarrow g[goal]$;
				\_goal  $\leftarrow goal$ \\
			}
		}
		$explored.insert(u)$;
		$vector<Edge> successor$; $ succ(u,successor)$;
		\\
			\For{$ auto$ $s : successor $} {
				$I ui \leftarrow s.get_target()$\\
				// ui not in E and ui not in f\\
				\If{$explored.find(ui) = explored.end() and current.find(ui) = current.end()$}{
						$g[ui] \leftarrow g[u] + cost(u,ui) frontier.push({g[ui],ui})$\\
						$current.insert(ui)$;
						$path[ui] \leftarrow u$
				}					
				\ElseIf{$current.find(ui) \neq current.end()$}{
					\If{ $g[u] + cost(u,ui) < g[ui]$ }{
						$g[ui] \leftarrow g[u] + cost(u,ui)$;
						$path[ui] \leftarrow u$
					}
				}				
				\ElseIf{$explored.find(ui) \neq explored.end()$}
				{
					\If{ $g[u] + cost(u,ui) < g[ui] $}{
						$explored.erase(explored.find(ui))$;
						$frontier.push({g[ui],ui})$;
						$current.insert(source)$;
					}
				}
		}
	}
}
\end{algorithm}
\clearpage
% ==========================================================================================================================
%  Implementation Section 2
% ==========================================================================================================================
\section[Implementation]{Implementation}
The implementation of Dijkstra utilizes several of the c++11 standard library data structures,
Below is how the data structures are defined and the running time of each function\cite{ northwestern}.
The core algorithm will be implemented under the betacore namespace.
%----------------------------------------
%	Std::Vector
% ---------------------------------------
\subsection{std::vector}
\begin{lstlisting}
	template<
    class T,
    class Allocator = std::allocator<T>
> class vector;
\end{lstlisting}
\begin{tabular}{ l l l }
\textbf{Constructors} & \textbf{Description} & \textbf{Big - OH}\\
vector$<$T$>$ v; & Make an empty vector. & O(1)\\
vector$<$T$>$ v(n); & Make a vector with N elements. & O(n)\\
vector$<$T$>$ v(n, value); & Make a vector with N elements, initialized to value. & O(n)\\
vector$<$T$>$ v(begin, end); & Make a vector and copy the elements from begin to end & O(n)\\
\end{tabular}
\\
\\
\\
\begin{tabular}{ l l l }
\textbf{Accessors} & \textbf{Description} & \textbf{Big - OH}\\
v[i]; & Return (or set) the I'th element. & O(1)\\
v.at(i); & Return (or set) the I'th element, with bounds checking. & O(1)\\
v.size(); & Return current number of elements. & O(1)\\
v.empty(); & Return true if vector is empty. & O(1)\\
v.begin(); & Return random access iterator to start. & O(1)\\
v.end(); & Return random access iterator to end. & O(1)\\
v.front(); & Return the first element. & O(1)\\
v.back(); & Return the last element. & O(1)\\
v.capacity(); & Return maximum number of elements. & O(1)\\
\end{tabular}
\\
\\
\\
\begin{tabular}{ l l l }
\textbf{Modifiers} & \textbf{Description} & \textbf{Big - OH}\\
v.push\_back(value); & Add value to end. & O(1) (amortized)\\
v.insert(iterator, value); & Insert value at the position indexed by iterator. & O(n)\\
v.pop\_back(); & Remove value from end. & O(1)\\
v.erase(iterator); & Erase value indexed by iterator. & O(n)\\
v.erase(begin, end); & Erase the elements from begin to end & O(n)\\
\end{tabular}
\clearpage
%----------------------------------------
%	Std::priority queue
% ---------------------------------------
\subsection{std::priority\_queue}\label{pq}
\begin{tabular}{ p{5cm} p{7cm} p{5cm}}
\textbf{Constructors} & \textbf{Description} & \textbf{Big - OH}\\
priority\_queue$<$T,  container$<$T$>$,  comparison$<$T$>$ $>$ q & Make an empty priority queue using the given container to hold values, and comparison to compare values. container defaults to vector$<$T$>$ and comparison defaults to less$<$T$>$. & O(1)\end{tabular}
\\
\\
\\
\begin{tabular}{ l l l }
\textbf{Accessors} & \textbf{Description} & \textbf{Big - OH}\\
q.top(); & Return the ``biggest'' element. & O(1)\\
q.size(); & Return current number of elements. & O(1)\\
q.empty(); & Return true if priority queue is empty. & O(1)
\end{tabular}
\\
\\
\\
\begin{tabular}{ l l l }
\textbf{Modifiers} & \textbf{Description} & \textbf{Big - OH}\\
q.push(value); & Add value to priority queue. & O(log n)\\
q.pop(); & Remove biggest value. & O(log n)\\
\end{tabular}
\clearpage
%----------------------------------------
%	Std::Set
% ---------------------------------------
\subsection{std::set} \label{stdset}
\begin{tabular}{ p{5cm} p{7cm} p{5cm}}
\textbf{Constructors} & \textbf{Description} & \textbf{Big - OH}\\
set $<$type, compare$>$ s; & Make an empty set. compare should be a binary predicate for ordering the set. It's optional and will default to a function that uses operator$<$. & O(1)\\
set $<$type, compare$>$ s(begin, end); & Make a set and copy the values from begin to end. & O(n log n)
\end{tabular}
\\
\\
\\
\begin{tabular}{ p{5cm} p{7cm}  p{5cm}}
\textbf{Modifiers} & \textbf{Description} & \textbf{Big - OH}\\
s.find(key) & Return an iterator pointing to an occurrence of key in s, or s.end() if key is not in s. & O(log n)\\
s.lower\_bound(key) & Return an iterator pointing to the first occurrence of  an item in s not less than key, or s.end() if no such item is found. & O(log n)\\
s.upper\_bound(key) & Return an iterator pointing to the first occurrence of  an item greater than key in s, or s.end() if no such item is found. & O(log n)\\
s.equal\_range(key) & Returns pair$<$lower\_bound(key), upper\_bound(key)$>$. & O(log n)\\
s.count(key) & Returns the number of items equal to key in s. & O(log n)\\
s.size() & Return current number of elements. & O(1)\\
s.empty() & Return true if set is empty. & O(1)\\
s.begin() & Return an iterator pointing to the first element. & O(1)\\
s.end() & Return an iterator pointing one past the last element. & O(1)
\end{tabular}
\clearpage
%----------------------------------------
%	Std::Map
% ---------------------------------------
\subsection{std::Map} 
\begin{tabular}{ p{5cm} p{7cm}  p{5cm} }
\textbf{Constructors} & \textbf{Description} & \textbf{Big - OH}\\
map$<$ key\_type, value\_type, key\_compare $>$ m; & Make an empty map. key\_compare should be a binary predicate for ordering the keys. It's optional and will default to a function that uses operator$<$. & O(1)\\
map$<$ key\_type, value\_type, key\_compare $>$ m(begin, end); & Make a map and copy the values from begin to end. & O(n log n)
\end{tabular}
\\
\\
\\
\begin{tabular}{ p{5cm} p{7cm}  p{5cm} }
\textbf{Accessors} & \textbf{Description} & \textbf{Big - OH}\\
m[key] & Return the value stored for key. This adds a default value if key not in map. & O(log n)\\
m.find(key) & Return an iterator pointing to a key-value pair, or m.end() if key is not in map. & O(log n)\\
m.lower\_bound(key) & Return an iterator pointing to the first pair containing key, or m.end() if key is not in map. & O(log n)\\
m.upper\_bound(key) & Return an iterator pointing one past the last pair containing key, or m.end() if key is not in map. & O(log n)\\
m.equal\_range(key) & Return a pair containing the lower and upper bounds for key. This may be more efficient than calling those functions separately. & O(log n)\\
m.size(); & Return current number of elements. & O(1)\\
m.empty(); & Return true if map is empty. & O(1)\\
m.begin() & Return an iterator pointing to the first pair. & O(1)\\
m.end() & Return an iterator pointing one past the last pair. & O(1) n)
\end{tabular}
\\
\\
\\
\begin{tabular}{ p{5cm} p{7cm}  p{5cm} }
\textbf{Modifiers} & \textbf{Description} & \textbf{Big - OH}\\
m[key] = value; & Store value under key in map. & O(log n)\\
m.insert(pair) & Inserts the <key, value> pair into the map. Equivalent to the above operation. & O(log n)
\end{tabular}
\subsection{std::pair}
\begin{tabular}{ p{5cm} p{10cm} }
default (1) & constexpr pair\\
copy / move (2) & template$<$class U, class V$>$ pair (const pair$<$U,V$>$\& pr);
					template$<$class U, class V$>$ pair (pair$<$U,V$>$\&\& pr);
					pair (const pair\& pr) = default;
					pair (pair\&\& pr) = default;\\
initialization (3) & pair (const first\_type\& a, const second\_type\& b);
					template$<$class U, class V$>$ pair (U\&\& a, V\&\& b);\\
piecewise (4) &		
					template $<$class... Args1, class... Args2$>$
  					pair (piecewise\_construct\_t pwc, tuple$<$Args1...$>$ first\_args,
                                   tuple$<$Args2...$>$ second\_args);
					
					
\end{tabular}
\begin{lstlisting}

template <class T1,class T2>
  pair<T1,T2> make_pair (T1 x, T2 y)
  {
    return ( pair<T1,T2>(x,y) );
  }
\end{lstlisting}
function to make a std::pair

%----------------------------------------
%	Betacore::Node
% ---------------------------------------
\subsection{Betacore::Node}
\begin{lstlisting}
	template<typename I>
	class Node{
		private:
		I id;
		std::string name;
		public:
			Node(I &id,std::string &name)
			std::string get_name()
			void setName(const std::string &name)
			I get_id()
	};
\end{lstlisting}
Helper class that can store minimal information about a node, 
more information can stored in the csv file
%----------------------------------------
%	Betacore::Edge
% ---------------------------------------
\subsection{Betacore::Edge}
\begin{lstlisting}
	template<typename T, typename I>
	class Edge{
		private:
			I id;
			I source;
			I target;
			T cost;
		public:
			Edge(){}
			Edge(I &source, I &target, T &cost)
			I get_source()
			I get_target()
			T get_cost()
	};
\end{lstlisting}
Helper class that can store minimal information about a Edge, 
more information can stored in the csv file
%----------------------------------------
%	Betacore::Graph
% ---------------------------------------
\subsection{Betacore::Graph}
\begin{lstlisting}
	template<typename T, typename I>
	class Graph{
		private:
			std::vector<betacore::Node<I>> nodes
			std::vector<betacore::Edge<T,I>> edges
			betacore::Node<I> * source
			std::vector<betacore::Node<I>> targets
			void parse_line(std::string &line)
		public:
			Graph()
			void successor(I &node, std::vector<Edge<T,I>> &result)
			void get_edges(std::vector<betacore::Edge<T,I>> &edges)
			Node<I> get_node(I id)
			void add_node(Node<I> &node)
			void remove_node(I id)
			load_from_file(std::string file_path)
			T cost(I u, I ui)
			void print()
	};
\end{lstlisting}

Betacore::graph is an implementation of a directed graph that reads from a
modified comma delimited file. This allows for the graph state to change
without recompiling the code, however this is a potential bottleneck due to
the read speed of a hard disk (for larger gig size files this should be
be modified to a stream and the graph split up into regions then load each region
only when needed, thus saving memory ). 

Template$<$typename T, typename I$>$ allows the precision of the graph type to 
be determined by the implementation. T being a float, double, or long double
used for floating point arithmetic. I being a char, int, long, long long int is
used for indexing the nodes. Depending on the size of the graph changing the 
data types for T and I can have a performance and precision impact on the graph.

%----------------------------------------
%	Betacore::Dijkstra
% ---------------------------------------
\subsection{Betacore::Dijkstra}  \label{betadij}
\begin{lstlisting}
	struct Dijkstra_Exception : public std::exception {
		const char * what () const throw () {
			return "Dijkstra Exception";
		}
	};

	template<typename T, typename I>
	class Dijkstra{
		private:
			std::priority_queue<std::pair<T,I>,std::vector<std::pair<T,I>>, std::greater<std::pair<T,I>> > frontier;
			std::set<I> current; 
			std::set<I> explored;
			T cost();
		public:
			Dijkstra(){
			}
			~Dijkstra(){
			}
		
			void run (
				I source,
				I goal,
				std::map<I,I> &path,
				std::function<T( I u, I ui)> &cost,
				std::function<void(I &node, std::vector<Edge<T,I>> &result)> &Succ
			 );
		
			void run (
				I source,
				std::vector<I> &goal_v,
				std::map<I,I> &path,
				std::function<T( I u, I ui)> &cost,
				std::function<void(I &node, std::vector<Edge<T,I>> &result)> &Succ
			 );
	
	};
\end{lstlisting}

Betacore::Dijkstra implementation utilizes the std::priority\_queue (see section \ref{pq}).
The priority\_queue uses the std::greater function which set the que by the value in edge cost$<$T$>$. The goal is the min value so using the grater function
so the value in first position will be the smallest, thus the shortest edge$<$T$>$. 
Limitation of using std::priority\_queue is that their is no contains method. That 
problem is overcome by keeping a std::set (see section \ref{stdset}) to keep track of nodes in the frontier.
So the std::priority\_queue frontier keeps the order of the edges and std::set current keeps track of the contains.
This adds double space complexity but saves from have to implement a new child class of std::priority\_queue. Nodes 
are know by their index type I and the edges  by the edge class.
\\
\\

\begin{lstlisting}
	std::function<T( I u, I ui)> &cost
\end{lstlisting}
This function passed into the algorithm determines the cost from node $u \to u_i$ and 
must be provided by the user and allows for the most flexibility.
\\
\begin{lstlisting}
	std::function<void(I &node, std::vector<Edge<T,I>> &result)> &Succ
\end{lstlisting}
This function passed into the algorithm determines then neighbors nodes of $u$ and
stores the result into a std::vector \&result. To change the implement just make sure
that you add the Edge$<$T,I$>$ index I do the vector list.
% ==========================================================================================================================
%  Proof of correctness Section 3
% ==========================================================================================================================

% \section[Proof of correctness]{Proof of correctness}
\section{Proof of correctness}
Note: running time doesn't include loading from file, its the running time of the algorithm. 
Their is an additional graph, not required by assignment,
that was used to verify the algorithm.
Due to simplistic nature of the graph\_01 it can show in an ideal case the algorithm takes shortest path (not ideal being negative cycle),
assuming it is provided by the Succ function(\ref{betadij}). 
\subsection{Flight Plans}

Sample Run output:

\begin{lstlisting}
	_______________________________________________________________
	Heuristics
	_______________________________________________________________
	../data/graph_gt_7_3.csv
	N,1,SFO
	N,2,ORD
	N,3,BOS
	N,4,PVD
	N,5,JFK
	N,6,BWI
	N,7,MIA
	N,8,DFW
	N,9,LAX
	#
	E,1,2,1846
	E,2,1,1846
	#
	E,1,8,1464
	E,8,1,1464
	#
	E,1,9,337
	E,9,1,337
	#
	E,2,3,867
	E,3,2,867
	#
	E,2,4,849
	E,4,2,849
	#
	E,2,5,740
	E,5,2,740
	#
	E,2,6,621
	E,6,2,621
	#
	E,2,8,802
	E,8,2,802
	#
	E,3,5,187
	E,5,3,187
	#
	E,3,7,1258
	E,7,3,1258
	#
	E,4,5,144
	E,5,4,144
	#
	E,5,6,184
	E,6,5,184
	#
	E,5,7,1090
	E,7,5,1090
	#
	E,5,8,1391
	E,8,5,1391
	#
	E,6,7,946
	E,7,6,946
	#
	E,7,8,1121
	E,8,7,1121
	#
	E,7,9,2342
	E,9,7,2342
	#
	E,8,9,1235
	E,9,8,1235
	#
	T,1,SFO
	T,9,LAX
	S,6,BWI
	_______________________________________________________________
	Edge:1->2 cost:1846
	Edge:2->1 cost:1846
	Edge:1->8 cost:1464
	Edge:8->1 cost:1464
	Edge:1->9 cost:337
	Edge:9->1 cost:337
	Edge:2->3 cost:867
	Edge:3->2 cost:867
	Edge:2->4 cost:849
	Edge:4->2 cost:849
	Edge:2->5 cost:740
	Edge:5->2 cost:740
	Edge:2->6 cost:621
	Edge:6->2 cost:621
	Edge:2->8 cost:802
	Edge:8->2 cost:802
	Edge:3->5 cost:187
	Edge:5->3 cost:187
	Edge:3->7 cost:1258
	Edge:7->3 cost:1258
	Edge:4->5 cost:144
	Edge:5->4 cost:144
	Edge:5->6 cost:184
	Edge:6->5 cost:184
	Edge:5->7 cost:1090
	Edge:7->5 cost:1090
	Edge:5->8 cost:1391
	Edge:8->5 cost:1391
	Edge:6->7 cost:946
	Edge:7->6 cost:946
	Edge:7->8 cost:1121
	Edge:8->7 cost:1121
	Edge:7->9 cost:2342
	Edge:9->7 cost:2342
	Edge:8->9 cost:1235
	Edge:9->8 cost:1235
	Nodes:1
	Nodes:2
	Nodes:3
	Nodes:4
	Nodes:5
	Nodes:6
	Nodes:7
	Nodes:8
	Nodes:9
	_______________________________________________________________
	Node U::6
	Other Goal Found:1	cost:0
	Other Goal Found:9	cost:0
	Adding to frontier node:2 cost:621
	Adding to frontier node:5 cost:184
	Adding to frontier node:7 cost:946
	Node U::5
	Other Goal Found:1	cost:0
	Other Goal Found:9	cost:0
	Adding to frontier node:3 cost:371
	Adding to frontier node:4 cost:328
	Adding to frontier node:8 cost:1575
	Node U::4
	Other Goal Found:1	cost:0
	Other Goal Found:9	cost:0
	Node U::3
	Other Goal Found:1	cost:0
	Other Goal Found:9	cost:0
	Node U::2
	Other Goal Found:1	cost:0
	Other Goal Found:9	cost:0
	Adding to frontier node:1 cost:2467
	+adding edge:2 cost:1423
	Node U::7
	Other Goal Found:1	cost:2467
	Other Goal Found:9	cost:0
	Adding to frontier node:9 cost:3288
	Node U::8
	Other Goal Found:1	cost:2467
	Other Goal Found:9	cost:3288
	+adding edge:8 cost:2658
	Node U::1
	Min Goal Found:1	cost:2467
	Other Goal Found:9	cost:2658
	Node U::9
	Other Goal Found:1	cost:2467
	Other Goal Found:9	cost:2658
	explored node count:8
	explored node:1
	explored node:2
	explored node:3
	explored node:4
	explored node:5
	explored node:6
	explored node:7
	explored node:8
	frontier node count:0
	path:
	1<-2<-6
	cost:2467
	Running time(includes std::cout):	0.000282s
	cpu start: 0	cpu end:1	CLOCKS_PER_SEC:1000
	cpu time(includes std::cout):	0.001s
	_______________________________________________________________

\end{lstlisting}
* Note the cpu run time may not appear accurate due to the running system (see System \\ information \ref{sysinfo})

Doing the trace by hand yielded similar results with the min path being BWI $\to$ ORD  $\to$ SFO. in the output 
the entire search state is dumped (which can hurt performance) so by looking at each choice the algorithm is taking (making sure it's being greedy).
we can verify the correctness for this instance (if the graph was larger test driven development would be advised ). 

\subsection{Missionaries and Cannibals}
With run of $n=3$ and $m=2$ \\
The graph in the format:\\
Each node represents the following\\

N: Type of node\\

\#: id of the node\\

Name: LHS(Missionaries\_Cannibals)::Boat(Missionaries\_Cannibals)::RHS(Missionaries\_Cannibals)\\
\\
Each Edge is source, target, cost\\
The Goal is to move from LHS $\to$ RHS
\\
Sample Run output:
\begin{lstlisting}
	_______________________________________________________________
	Heuristics
	_______________________________________________________________
	../data/graph_can_n_3_m_2.csv
	N,0,N::3_2::0_0::0_0
	N,1,N::2_1::1_1::0_0
	N,2,N::3_0::0_2::0_0
	N,3,N::1_2::2_0::0_0
	N,4,N::2_1::0_1::1_0
	N,5,N::2_1::1_0::0_1
	N,6,N::2_0::0_1::0_1
	N,7,N::3_0::0_1::0_1
	N,8,N::1_1::1_1::1_0
	N,9,N::2_0::0_2::1_0
	N,10,N::2_0::1_1::0_1
	N,11,N::1_1::2_0::0_1
	N,12,N::1_1::0_1::2_0
	N,13,N::1_1::1_0::1_1
	N,14,N::2_0::0_1::1_1
	N,15,N::2_0::1_0::0_2
	N,16,N::1_0::2_0::0_1
	N,17,N::1_0::1_1::2_0
	N,18,N::1_0::0_2::2_0
	N,19,N::1_0::0_1::2_1
	N,20,N::0_1::0_1::3_0
	N,21,N::1_0::1_0::1_2
	N,22,N::0_0::1_1::2_1
	N,23,N::0_0_::0_2::3_0
	N,24,N::0_0::0_0::3_2
	E,0,1,1
	E,0,2,1
	E,0,3,1
	E,1,4,1
	E,1,5,1
	E,2,6,1
	E,4,7,1
	E,4,8,1
	E,5,9,1
	E,5,10,1
	E,6,9,1
	E,7,11,1
	E,7,12,1
	E,8,13,1
	E,9,13,1
	E,11,15,1
	E,11,16,1
	E,12,16,1
	E,13,17,1
	E,14,18,1
	E,15,19,1
	E,16,20,1
	E,17,19,1
	E,17,21,1
	E,18,21,1
	E,19,22,1
	E,20,23,1
	E,22,24,1
	E,23,24,1
	S,0,N::3_2::0_0::0_0
	T,24,N::0_0::0_0::3_2
	_______________________________________________________________
	Edge:0->1 cost:1
	Edge:0->2 cost:1
	Edge:0->3 cost:1
	Edge:1->4 cost:1
	Edge:1->5 cost:1
	Edge:2->6 cost:1
	Edge:4->7 cost:1
	Edge:4->8 cost:1
	Edge:5->9 cost:1
	Edge:5->10 cost:1
	Edge:6->9 cost:1
	Edge:7->11 cost:1
	Edge:7->12 cost:1
	Edge:8->13 cost:1
	Edge:9->13 cost:1
	Edge:11->15 cost:1
	Edge:11->16 cost:1
	Edge:12->16 cost:1
	Edge:13->17 cost:1
	Edge:14->18 cost:1
	Edge:15->19 cost:1
	Edge:16->20 cost:1
	Edge:17->19 cost:1
	Edge:17->21 cost:1
	Edge:18->21 cost:1
	Edge:19->22 cost:1
	Edge:20->23 cost:1
	Edge:22->24 cost:1
	Edge:23->24 cost:1
	Nodes:0
	Nodes:1
	Nodes:2
	Nodes:3
	Nodes:4
	Nodes:5
	Nodes:6
	Nodes:7
	Nodes:8
	Nodes:9
	Nodes:10
	Nodes:11
	Nodes:12
	Nodes:13
	Nodes:14
	Nodes:15
	Nodes:16
	Nodes:17
	Nodes:18
	Nodes:19
	Nodes:20
	Nodes:21
	Nodes:22
	Nodes:23
	Nodes:24
	_______________________________________________________________
	Node U::0
	Other Goal Found:24	cost:0
	Adding to frontier node:1 cost:1
	Adding to frontier node:2 cost:1
	Adding to frontier node:3 cost:1
	Node U::1
	Other Goal Found:24	cost:0
	Adding to frontier node:4 cost:2
	Adding to frontier node:5 cost:2
	Node U::2
	Other Goal Found:24	cost:0
	Adding to frontier node:6 cost:2
	Node U::3
	Other Goal Found:24	cost:0
	Node U::4
	Other Goal Found:24	cost:0
	Adding to frontier node:7 cost:3
	Adding to frontier node:8 cost:3
	Node U::5
	Other Goal Found:24	cost:0
	Adding to frontier node:9 cost:3
	Adding to frontier node:10 cost:3
	Node U::6
	Other Goal Found:24	cost:0
	Node U::7
	Other Goal Found:24	cost:0
	Adding to frontier node:11 cost:4
	Adding to frontier node:12 cost:4
	Node U::8
	Other Goal Found:24	cost:0
	Adding to frontier node:13 cost:4
	Node U::9
	Other Goal Found:24	cost:0
	Node U::10
	Other Goal Found:24	cost:0
	Node U::11
	Other Goal Found:24	cost:0
	Adding to frontier node:15 cost:5
	Adding to frontier node:16 cost:5
	Node U::12
	Other Goal Found:24	cost:0
	Node U::13
	Other Goal Found:24	cost:0
	Adding to frontier node:17 cost:5
	Node U::15
	Other Goal Found:24	cost:0
	Adding to frontier node:19 cost:6
	Node U::16
	Other Goal Found:24	cost:0
	Adding to frontier node:20 cost:6
	Node U::17
	Other Goal Found:24	cost:0
	Adding to frontier node:21 cost:6
	Node U::19
	Other Goal Found:24	cost:0
	Adding to frontier node:22 cost:7
	Node U::20
	Other Goal Found:24	cost:0
	Adding to frontier node:23 cost:7
	Node U::21
	Other Goal Found:24	cost:0
	Node U::22
	Other Goal Found:24	cost:0
	Adding to frontier node:24 cost:8
	Node U::23
	Other Goal Found:24	cost:8
	Node U::24
	Min Goal Found:24	cost:8
	explored node count:23
	explored node:0
	explored node:1
	explored node:2
	explored node:3
	explored node:4
	explored node:5
	explored node:6
	explored node:7
	explored node:8
	explored node:9
	explored node:10
	explored node:11
	explored node:12
	explored node:13
	explored node:15
	explored node:16
	explored node:17
	explored node:19
	explored node:20
	explored node:21
	explored node:22
	explored node:23
	explored node:24
	frontier node count:0
	path:
	24<-22<-19<-15<-11<-7<-4<-1<-0
	cost:8
	Running time(includes std::cout):	0.0004963s
	cpu start: 1	cpu end:1	CLOCKS_PER_SEC:1000
	cpu time(includes std::cout):	0s
	_______________________________________________________________

\end{lstlisting}
* Note the cpu run time may not appear accurate due to the running system (see System  information \ref{sysinfo})
\\
\\
The path\\
24$\leftarrow$22$\leftarrow$19$\leftarrow$15$\leftarrow$11$\leftarrow$7$\leftarrow$4$\leftarrow$1$\leftarrow$0
matches the tree state of the problem and is the length of the depth of the tree. 
Each edge havening a cost of 1 yields the correct cost which matches the numbers of edges
With run of $n=4$ and $m=3$ 
The graph in the format:\\
Each node represents the following\\

N: Type of node\\

\#: id of the node\\

Name: LHS(Missionaries\_Cannibals)::Boat(Missionaries\_Cannibals)::RHS(Missionaries\_Cannibals)\\
\\
Each Edge is source, target, cost\\
The Goal is to move from LHS $\to$ RHS

Sample Run output:
\begin{lstlisting}
	_______________________________________________________________
	Heuristics
	_______________________________________________________________
	../data/graph_can_n_4_m_3.csv
	N,0,4_3::0_0::0_0
	N,1,3_2::1_1::0_0
	N,2,4_1::0_2::0_0
	N,3,2_3::2_0::0_0
	N,4,3_2::1_0::0_1
	N,5,3_2::0_1::1_0
	N,6,4_1::0_1::0_1
	N,7,3_1::1_1::0_1
	N,8,2_2::2_0::0_1
	N,9,2_2::1_1::1_0
	N,10,3_1::0_2::1_0
	N,11,4_0::0_2::0_1
	N,12,3_1::1_0::0_2
	N,13,3_1::0_1::1_1
	N,14,2_2::1_0::1_1
	N,15,2_2::0_1::2_0
	N,16,4_0::0_1::0_2
	N,17,2_1::2_0::0_2
	N,18,3_0::1_1::0_2
	N,19,3_0::0_2::1_1
	N,20,2_1::1_1::1_1
	N,21,1_2::2_0::1_1
	N,22,2_1::0_2::2_0
	N,23,2_1::1_0::1_2
	N,24,3_0::1_0::0_3
	N,25,3_0::0_1::1_2
	N,26,2_1::0_1::2_1
	N,27,2_1::1_0::1_2
	N,28,2_0::2_0::0_3
	N,29,2_0::0_2::2_1
	N,30,1_1::1_1::2_1
	N,31,2_0::1_0::1_3
	N,32,2_0::0_1::2_2
	N,33,1_1::0_1::3_1
	N,34,1_1::1_0::2_2
	N,35,1_0::1_1::2_2
	N,36,1_0::0_2::3_1
	N,37,0_1::1_1::3_1
	N,38,0_1::2_0::2_2
	N,39,1_0::1_0::2_3
	N,40,1_0::0_1::3_2
	N,41,0_1::1_0::3_2
	N,42,0_1::0_1::4_1
	N,43,0_0::1_1::3_2
	N,44,0_0::0_2::4_1
	N,45,0_0::0_0::4_3
	E,0,1,1
	E,0,2,1
	E,0,3,1
	E,1,4,1
	E,1,5,1
	E,2,6,1
	E,4,7,1
	E,4,8,1
	E,5,9,1
	E,5,10,1
	E,6,11,1
	E,7,12,1
	E,7,13,1
	E,8,14,1
	E,9,14,1
	E,9,15,1
	E,10,13,1
	E,11,16,1
	E,12,17,1
	E,12,18,1
	E,13,19,1
	E,13,20,1
	E,14,20,1
	E,14,21,1
	E,15,22,1
	E,15,23,1
	E,16,18,1
	E,17,23,1
	E,18,24,1
	E,18,25,1
	E,19,25,1
	E,20,26,1
	E,20,23,1
	E,22,26,1
	E,24,28,1
	E,26,29,1
	E,26,30,1
	E,28,31,1
	E,29,32,1
	E,30,33,1
	E,30,34,1
	E,32,35,1
	E,33,36,1
	E,33,37,1
	E,34,38,1
	E,35,39,1
	E,35,40,1
	E,36,40,1
	E,37,41,1
	E,37,42,1
	E,38,41,1
	E,40,43,1
	E,41,43,1
	E,42,44,1
	E,43,45,1
	E,44,45,1
	S,0,4_3::0_0::0_0
	T,45,0_0::0_0::4_3
	_______________________________________________________________
	Edge:0->1 cost:1
	Edge:0->2 cost:1
	Edge:0->3 cost:1
	Edge:1->4 cost:1
	Edge:1->5 cost:1
	Edge:2->6 cost:1
	Edge:4->7 cost:1
	Edge:4->8 cost:1
	Edge:5->9 cost:1
	Edge:5->10 cost:1
	Edge:6->11 cost:1
	Edge:7->12 cost:1
	Edge:7->13 cost:1
	Edge:8->14 cost:1
	Edge:9->14 cost:1
	Edge:9->15 cost:1
	Edge:10->13 cost:1
	Edge:11->16 cost:1
	Edge:12->17 cost:1
	Edge:12->18 cost:1
	Edge:13->19 cost:1
	Edge:13->20 cost:1
	Edge:14->20 cost:1
	Edge:14->21 cost:1
	Edge:15->22 cost:1
	Edge:15->23 cost:1
	Edge:16->18 cost:1
	Edge:17->23 cost:1
	Edge:18->24 cost:1
	Edge:18->25 cost:1
	Edge:19->25 cost:1
	Edge:20->26 cost:1
	Edge:20->23 cost:1
	Edge:22->26 cost:1
	Edge:24->28 cost:1
	Edge:26->29 cost:1
	Edge:26->30 cost:1
	Edge:28->31 cost:1
	Edge:29->32 cost:1
	Edge:30->33 cost:1
	Edge:30->34 cost:1
	Edge:32->35 cost:1
	Edge:33->36 cost:1
	Edge:33->37 cost:1
	Edge:34->38 cost:1
	Edge:35->39 cost:1
	Edge:35->40 cost:1
	Edge:36->40 cost:1
	Edge:37->41 cost:1
	Edge:37->42 cost:1
	Edge:38->41 cost:1
	Edge:40->43 cost:1
	Edge:41->43 cost:1
	Edge:42->44 cost:1
	Edge:43->45 cost:1
	Edge:44->45 cost:1
	Nodes:0
	Nodes:1
	Nodes:2
	Nodes:3
	Nodes:4
	Nodes:5
	Nodes:6
	Nodes:7
	Nodes:8
	Nodes:9
	Nodes:10
	Nodes:11
	Nodes:12
	Nodes:13
	Nodes:14
	Nodes:15
	Nodes:16
	Nodes:17
	Nodes:18
	Nodes:19
	Nodes:20
	Nodes:21
	Nodes:22
	Nodes:23
	Nodes:24
	Nodes:25
	Nodes:26
	Nodes:27
	Nodes:28
	Nodes:29
	Nodes:30
	Nodes:31
	Nodes:32
	Nodes:33
	Nodes:34
	Nodes:35
	Nodes:36
	Nodes:37
	Nodes:38
	Nodes:39
	Nodes:40
	Nodes:41
	Nodes:42
	Nodes:43
	Nodes:44
	Nodes:45
	_______________________________________________________________
	Node U::0
	Other Goal Found:45	cost:0
	Adding to frontier node:1 cost:1
	Adding to frontier node:2 cost:1
	Adding to frontier node:3 cost:1
	Node U::1
	Other Goal Found:45	cost:0
	Adding to frontier node:4 cost:2
	Adding to frontier node:5 cost:2
	Node U::2
	Other Goal Found:45	cost:0
	Adding to frontier node:6 cost:2
	Node U::3
	Other Goal Found:45	cost:0
	Node U::4
	Other Goal Found:45	cost:0
	Adding to frontier node:7 cost:3
	Adding to frontier node:8 cost:3
	Node U::5
	Other Goal Found:45	cost:0
	Adding to frontier node:9 cost:3
	Adding to frontier node:10 cost:3
	Node U::6
	Other Goal Found:45	cost:0
	Adding to frontier node:11 cost:3
	Node U::7
	Other Goal Found:45	cost:0
	Adding to frontier node:12 cost:4
	Adding to frontier node:13 cost:4
	Node U::8
	Other Goal Found:45	cost:0
	Adding to frontier node:14 cost:4
	Node U::9
	Other Goal Found:45	cost:0
	Adding to frontier node:15 cost:4
	Node U::10
	Other Goal Found:45	cost:0
	Node U::11
	Other Goal Found:45	cost:0
	Adding to frontier node:16 cost:4
	Node U::12
	Other Goal Found:45	cost:0
	Adding to frontier node:17 cost:5
	Adding to frontier node:18 cost:5
	Node U::13
	Other Goal Found:45	cost:0
	Adding to frontier node:19 cost:5
	Adding to frontier node:20 cost:5
	Node U::14
	Other Goal Found:45	cost:0
	Adding to frontier node:21 cost:5
	Node U::15
	Other Goal Found:45	cost:0
	Adding to frontier node:22 cost:5
	Adding to frontier node:23 cost:5
	Node U::16
	Other Goal Found:45	cost:0
	Node U::17
	Other Goal Found:45	cost:0
	Node U::18
	Other Goal Found:45	cost:0
	Adding to frontier node:24 cost:6
	Adding to frontier node:25 cost:6
	Node U::19
	Other Goal Found:45	cost:0
	Node U::20
	Other Goal Found:45	cost:0
	Adding to frontier node:26 cost:6
	Node U::21
	Other Goal Found:45	cost:0
	Node U::22
	Other Goal Found:45	cost:0
	Node U::23
	Other Goal Found:45	cost:0
	Node U::24
	Other Goal Found:45	cost:0
	Adding to frontier node:28 cost:7
	Node U::25
	Other Goal Found:45	cost:0
	Node U::26
	Other Goal Found:45	cost:0
	Adding to frontier node:29 cost:7
	Adding to frontier node:30 cost:7
	Node U::28
	Other Goal Found:45	cost:0
	Adding to frontier node:31 cost:8
	Node U::29
	Other Goal Found:45	cost:0
	Adding to frontier node:32 cost:8
	Node U::30
	Other Goal Found:45	cost:0
	Adding to frontier node:33 cost:8
	Adding to frontier node:34 cost:8
	Node U::31
	Other Goal Found:45	cost:0
	Node U::32
	Other Goal Found:45	cost:0
	Adding to frontier node:35 cost:9
	Node U::33
	Other Goal Found:45	cost:0
	Adding to frontier node:36 cost:9
	Adding to frontier node:37 cost:9
	Node U::34
	Other Goal Found:45	cost:0
	Adding to frontier node:38 cost:9
	Node U::35
	Other Goal Found:45	cost:0
	Adding to frontier node:39 cost:10
	Adding to frontier node:40 cost:10
	Node U::36
	Other Goal Found:45	cost:0
	Node U::37
	Other Goal Found:45	cost:0
	Adding to frontier node:41 cost:10
	Adding to frontier node:42 cost:10
	Node U::38
	Other Goal Found:45	cost:0
	Node U::39
	Other Goal Found:45	cost:0
	Node U::40
	Other Goal Found:45	cost:0
	Adding to frontier node:43 cost:11
	Node U::41
	Other Goal Found:45	cost:0
	Node U::42
	Other Goal Found:45	cost:0
	Adding to frontier node:44 cost:11
	Node U::43
	Other Goal Found:45	cost:0
	Adding to frontier node:45 cost:12
	Node U::44
	Other Goal Found:45	cost:12
	Node U::45
	Min Goal Found:45	cost:12
	explored node count:45
	explored node:0
	explored node:1
	explored node:2
	explored node:3
	explored node:4
	explored node:5
	explored node:6
	explored node:7
	explored node:8
	explored node:9
	explored node:10
	explored node:11
	explored node:12
	explored node:13
	explored node:14
	explored node:15
	explored node:16
	explored node:17
	explored node:18
	explored node:19
	explored node:20
	explored node:21
	explored node:22
	explored node:23
	explored node:24
	explored node:25
	explored node:26
	explored node:28
	explored node:29
	explored node:30
	explored node:31
	explored node:32
	explored node:33
	explored node:34
	explored node:35
	explored node:36
	explored node:37
	explored node:38
	explored node:39
	explored node:40
	explored node:41
	explored node:42
	explored node:43
	explored node:44
	explored node:45
	frontier node count:0
	path:
	45<-43<-40<-35<-32<-29<-26<-20<-13<-7<-4<-1<-0
	cost:12
	Running time(includes std::cout):	0.0010232s
	cpu start: 1	cpu end:2	CLOCKS_PER_SEC:1000
	cpu time(includes std::cout):	0.001s
	_______________________________________________________________

\end{lstlisting}
* Note the cpu run time may not appear accurate due to the running system (see System information \ref{sysinfo})


45$\leftarrow$43$\leftarrow$40$\leftarrow$35$\leftarrow$32$\leftarrow$29$\leftarrow$26$\leftarrow$20$\leftarrow$13$\leftarrow$7$\leftarrow$4$\leftarrow$1$\leftarrow$0
the path can be trace from the source to the sink with the sink\\target state matching the gaol state
\\
The output cost 12 is correct because the depth of the tree which represents
this problem is 12 and because each edge has a weight of 1 the cost should equal the depth of the tree.

\subsection{System information}\label{sysinfo}
clinfo.exe dump of system information. 
Note The above runs where running on cl.exe in debug mode on Windows 10 x64
\begin{lstlisting}
Number of platforms:				 1
  Platform Profile:				 FULL_PROFILE
  Platform Version:				 OpenCL 2.0 AMD-APP (2264.11)
  Platform Name:				 AMD Accelerated Parallel Processing
  Platform Vendor:				 Advanced Micro Devices, Inc.
  Platform Extensions:				 cl_khr_icd cl_khr_d3d10_sharing cl_khr_d3d11_sharing cl_khr_dx9_media_sharing cl_amd_event_callback cl_amd_offline_devices 


  Platform Name:				 AMD Accelerated Parallel Processing
Number of devices:				 2
  Device Type:					 CL_DEVICE_TYPE_GPU
  Vendor ID:					 1002h
  Board name:					 AMD Radeon HD 7800 Series
  Device Topology:				 PCI[ B#1, D#0, F#0 ]
  Max compute units:				 16
  Max work items dimensions:			 3
    Max work items[0]:				 256
    Max work items[1]:				 256
    Max work items[2]:				 256
  Max work group size:				 256
  Preferred vector width char:			 4
  Preferred vector width short:			 2
  Preferred vector width int:			 1
  Preferred vector width long:			 1
  Preferred vector width float:			 1
  Preferred vector width double:		 1
  Native vector width char:			 4
  Native vector width short:			 2
  Native vector width int:			 1
  Native vector width long:			 1
  Native vector width float:			 1
  Native vector width double:			 1
  Max clock frequency:				 860Mhz
  Address bits:					 32
  Max memory allocation:			 1409286144
  Image support:				 Yes
  Max number of images read arguments:		 128
  Max number of images write arguments:		 8
  Max image 2D width:				 16384
  Max image 2D height:				 16384
  Max image 3D width:				 2048
  Max image 3D height:				 2048
  Max image 3D depth:				 2048
  Max samplers within kernel:			 16
  Max size of kernel argument:			 1024
  Alignment (bits) of base address:		 2048
  Minimum alignment (bytes) for any datatype:	 128
  Single precision floating point capability
    Denorms:					 No
    Quiet NaNs:					 Yes
    Round to nearest even:			 Yes
    Round to zero:				 Yes
    Round to +ve and infinity:			 Yes
    IEEE754-2008 fused multiply-add:		 Yes
  Cache type:					 Read/Write
  Cache line size:				 64
  Cache size:					 16384
  Global memory size:				 2147483648
  Constant buffer size:				 65536
  Max number of constant args:			 8
  Local memory type:				 Scratchpad
  Local memory size:				 32768
  Max pipe arguments:				 0
  Max pipe active reservations:			 0
  Max pipe packet size:				 0
  Max global variable size:			 0
  Max global variable preferred total size:	 0
  Max read/write image args:			 0
  Max on device events:				 0
  Queue on device max size:			 0
  Max on device queues:				 0
  Queue on device preferred size:		 0
  SVM capabilities:				 
    Coarse grain buffer:			 No
    Fine grain buffer:				 No
    Fine grain system:				 No
    Atomics:					 No
  Preferred platform atomic alignment:		 0
  Preferred global atomic alignment:		 0
  Preferred local atomic alignment:		 0
  Kernel Preferred work group size multiple:	 64
  Error correction support:			 0
  Unified memory for Host and Device:		 0
  Profiling timer resolution:			 1
  Device endianess:				 Little
  Available:					 Yes
  Compiler available:				 Yes
  Execution capabilities:				 
    Execute OpenCL kernels:			 Yes
    Execute native function:			 No
  Queue on Host properties:				 
    Out-of-Order:				 No
    Profiling :					 Yes
  Queue on Device properties:				 
    Out-of-Order:				 No
    Profiling :					 No
  Platform ID:					 00007FFE8904B188
  Name:						 Pitcairn
  Vendor:					 Advanced Micro Devices, Inc.
  Device OpenCL C version:			 OpenCL C 1.2 
  Driver version:				 2264.11
  Profile:					 FULL_PROFILE
  Version:					 OpenCL 1.2 AMD-APP (2264.11)
  Extensions:					 cl_khr_fp64 cl_amd_fp64 cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics cl_khr_int64_base_atomics cl_khr_int64_extended_atomics cl_khr_3d_image_writes cl_khr_byte_addressable_store cl_khr_gl_sharing cl_amd_device_attribute_query cl_amd_vec3 cl_amd_printf cl_amd_media_ops cl_amd_media_ops2 cl_amd_popcnt cl_khr_d3d10_sharing cl_khr_d3d11_sharing cl_khr_dx9_media_sharing cl_khr_image2d_from_buffer cl_khr_spir cl_khr_gl_event cl_amd_liquid_flash 


  Device Type:					 CL_DEVICE_TYPE_CPU
  Vendor ID:					 1002h
  Board name:					 
  Max compute units:				 4
  Max work items dimensions:			 3
    Max work items[0]:				 1024
    Max work items[1]:				 1024
    Max work items[2]:				 1024
  Max work group size:				 1024
  Preferred vector width char:			 16
  Preferred vector width short:			 8
  Preferred vector width int:			 4
  Preferred vector width long:			 2
  Preferred vector width float:			 8
  Preferred vector width double:		 4
  Native vector width char:			 16
  Native vector width short:			 8
  Native vector width int:			 4
  Native vector width long:			 2
  Native vector width float:			 8
  Native vector width double:			 4
  Max clock frequency:				 3504Mhz
  Address bits:					 64
  Max memory allocation:			 4275856384
  Image support:				 Yes
  Max number of images read arguments:		 128
  Max number of images write arguments:		 64
  Max image 2D width:				 8192
  Max image 2D height:				 8192
  Max image 3D width:				 2048
  Max image 3D height:				 2048
  Max image 3D depth:				 2048
  Max samplers within kernel:			 16
  Max size of kernel argument:			 4096
  Alignment (bits) of base address:		 1024
  Minimum alignment (bytes) for any datatype:	 128
  Single precision floating point capability
    Denorms:					 Yes
    Quiet NaNs:					 Yes
    Round to nearest even:			 Yes
    Round to zero:				 Yes
    Round to +ve and infinity:			 Yes
    IEEE754-2008 fused multiply-add:		 Yes
  Cache type:					 Read/Write
  Cache line size:				 64
  Cache size:					 32768
  Global memory size:				 17103425536
  Constant buffer size:				 65536
  Max number of constant args:			 8
  Local memory type:				 Global
  Local memory size:				 32768
  Max pipe arguments:				 16
  Max pipe active reservations:			 16
  Max pipe packet size:				 4275856384
  Max global variable size:			 1879048192
  Max global variable preferred total size:	 1879048192
  Max read/write image args:			 64
  Max on device events:				 0
  Queue on device max size:			 0
  Max on device queues:				 0
  Queue on device preferred size:		 0
  SVM capabilities:				 
    Coarse grain buffer:			 No
    Fine grain buffer:				 No
    Fine grain system:				 No
    Atomics:					 No
  Preferred platform atomic alignment:		 0
  Preferred global atomic alignment:		 0
  Preferred local atomic alignment:		 0
  Kernel Preferred work group size multiple:	 1
  Error correction support:			 0
  Unified memory for Host and Device:		 1
  Profiling timer resolution:			 292
  Device endianess:				 Little
  Available:					 Yes
  Compiler available:				 Yes
  Execution capabilities:				 
    Execute OpenCL kernels:			 Yes
    Execute native function:			 Yes
  Queue on Host properties:				 
    Out-of-Order:				 No
    Profiling :					 Yes
  Queue on Device properties:				 
    Out-of-Order:				 No
    Profiling :					 No
  Platform ID:					 00007FFE8904B188
  Name:						 Intel(R) Core(TM) i5-6600K CPU @ 3.50GHz
  Vendor:					 GenuineIntel
  Device OpenCL C version:			 OpenCL C 1.2 
  Driver version:				 2264.11 (sse2,avx)
  Profile:					 FULL_PROFILE
  Version:					 OpenCL 1.2 AMD-APP (2264.11)
  Extensions:					 cl_khr_fp64 cl_amd_fp64 cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics cl_khr_int64_base_atomics cl_khr_int64_extended_atomics cl_khr_3d_image_writes cl_khr_byte_addressable_store cl_khr_gl_sharing cl_ext_device_fission cl_amd_device_attribute_query cl_amd_vec3 cl_amd_printf cl_amd_media_ops cl_amd_media_ops2 cl_amd_popcnt cl_khr_d3d10_sharing cl_khr_spir cl_khr_gl_event 
\end{lstlisting}
% //END

\section{ Sources of Error}
There could be some sources of error in my graph csv files, 
incorrectly adding edges or mistyping the graph state for the Cannibals and Missionaries.

\bibliographystyle{unsrt}
\bibliography{bib}


\end{document}
